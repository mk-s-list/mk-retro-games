<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Neon Tetris</title>

<style>
body{
  margin:0;
  background:#000;
  color:#0ff;
  font-family: monospace;
  text-align:center;
}

h1{
  margin:10px 0;
  text-shadow:0 0 10px #0ff;
}

canvas{
  background:#111;
  box-shadow:0 0 20px #0ff;
  touch-action:none;
}

#hint{
  color:#aaa;
  font-size:14px;
  margin-top:8px;
}
</style>
</head>

<body>
<h1>Neon Tetris</h1>
<canvas id="tetris" width="240" height="400"></canvas>
<div id="hint">Swipe ◀ ▶ ⬇ | Tap = Rotate</div>

<!-- SOUNDS -->
<audio id="move" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3"></audio>
<audio id="rotate" src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3"></audio>
<audio id="drop" src="https://assets.mixkit.co/active_storage/sfx/2572/2572-preview.mp3"></audio>
<audio id="clear" src="https://assets.mixkit.co/active_storage/sfx/2594/2594-preview.mp3"></audio>
<audio id="gameover" src="https://assets.mixkit.co/active_storage/sfx/2578/2578-preview.mp3"></audio>

<script>
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
ctx.scale(20,20);

const sounds = {
  move:document.getElementById("move"),
  rotate:document.getElementById("rotate"),
  drop:document.getElementById("drop"),
  clear:document.getElementById("clear"),
  gameover:document.getElementById("gameover")
};

function play(s){ sounds[s].currentTime=0; sounds[s].play(); }

const arena = createMatrix(12,20);
const colors = [null,"#0ff","#f0f","#ff0","#0f0","#f00","#00f","#fa0"];

const player = {
  pos:{x:0,y:0},
  matrix:null
};

function createMatrix(w,h){
  const m=[];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

function createPiece(type){
  if(type==="T") return [[0,0,0],[1,1,1],[0,1,0]];
  if(type==="O") return [[2,2],[2,2]];
  if(type==="L") return [[0,3,0],[0,3,0],[0,3,3]];
  if(type==="J") return [[0,4,0],[0,4,0],[4,4,0]];
  if(type==="I") return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==="S") return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==="Z") return [[7,7,0],[0,7,7],[0,0,0]];
}

function drawMatrix(matrix,offset){
  matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v){
        ctx.fillStyle=colors[v];
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) arena[y+player.pos.y][x+player.pos.x]=v;
    });
  });
}

function collide(arena,player){
  for(let y=0;y<player.matrix.length;y++){
    for(let x=0;x<player.matrix[y].length;x++){
      if(player.matrix[y][x] &&
         (arena[y+player.pos.y] &&
          arena[y+player.pos.y][x+player.pos.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function rotate(matrix){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
    }
  }
  matrix.forEach(r=>r.reverse());
}

function playerRotate(){
  rotate(player.matrix);
  if(collide(arena,player)){
    rotate(player.matrix);
    rotate(player.matrix);
    rotate(player.matrix);
  } else play("rotate");
}

function playerMove(dir){
  player.pos.x+=dir;
  if(collide(arena,player)) player.pos.x-=dir;
  else play("move");
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    resetPlayer();
    arenaSweep();
    play("drop");
  }
}

function arenaSweep(){
  outer:for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]===0) continue outer;
    }
    arena.splice(y,1);
    arena.unshift(new Array(12).fill(0));
    play("clear");
  }
}

function resetPlayer(){
  const pieces="TJLOSZI";
  player.matrix=createPiece(pieces[Math.random()*pieces.length|0]);
  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
  if(collide(arena,player)){
    arena.forEach(r=>r.fill(0));
    play("gameover");
  }
}

function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
}

let last=0,dropCounter=0,dropInterval=800;
function update(time=0){
  const delta=time-last;
  last=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval){
    playerDrop();
    dropCounter=0;
  }
  draw();
  requestAnimationFrame(update);
}

resetPlayer();
update();

let sx=0,sy=0;
canvas.addEventListener("touchstart",e=>{
  sx=e.touches[0].clientX;
  sy=e.touches[0].clientY;
});

canvas.addEventListener("touchend",e=>{
  const dx=e.changedTouches[0].clientX-sx;
  const dy=e.changedTouches[0].clientY-sy;

  if(Math.abs(dx)>Math.abs(dy)){
    dx>0?playerMove(1):playerMove(-1);
  }else{
    if(dy>30) playerDrop();
    else playerRotate();
  }
});
</script>
</body>
</html>
