<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Tetris</title>
<style>
body{
  margin:0;
  background:#05010a;
  color:#0ff;
  font-family:Arial, sans-serif;
  text-align:center;
}
canvas{
  background:#0a0014;
  box-shadow:0 0 20px #0ff;
  margin-top:10px;
}
h2{color:#0ff;text-shadow:0 0 10px #0ff;}
</style>
</head>
<body>

<h2>Neon Tetris</h2>
<canvas id="tetris" width="240" height="400"></canvas>

<script>
const canvas=document.getElementById("tetris");
const ctx=canvas.getContext("2d");
ctx.scale(20,20);

const colors=[
  null,
  "#00ffff",
  "#ff00ff",
  "#00ff00",
  "#ffff00",
  "#ff0000",
  "#0000ff",
  "#ff8800"
];

function arenaSweep(){
  outer: for(let y=arena.length-1;y>0;--y){
    for(let x=0;x<arena[y].length;++x){
      if(arena[y][x]===0) continue outer;
    }
    const row=arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    ++y;
  }
}

function collide(arena,player){
  const m=player.matrix;
  const o=player.pos;
  for(let y=0;y<m.length;++y){
    for(let x=0;x<m[y].length;++x){
      if(m[y][x]!==0 &&
        (arena[y+o.y] &&
         arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function createMatrix(w,h){
  const m=[];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

function createPiece(type){
  if(type==="T") return [[0,1,0],[1,1,1],[0,0,0]];
  if(type==="O") return [[2,2],[2,2]];
  if(type==="L") return [[0,3,0],[0,3,0],[0,3,3]];
  if(type==="J") return [[0,4,0],[0,4,0],[4,4,0]];
  if(type==="I") return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==="S") return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==="Z") return [[7,7,0],[0,7,7],[0,0,0]];
}

function drawMatrix(m,o){
  m.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        ctx.fillStyle=colors[v];
        ctx.fillRect(x+o.x,y+o.y,1,1);
      }
    });
  });
}

function draw(){
  ctx.fillStyle="#05010a";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0) arena[y+player.pos.y][x+player.pos.x]=v;
    });
  });
}

function rotate(m){
  for(let y=0;y<m.length;++y){
    for(let x=0;x<y;++x){
      [m[x][y],m[y][x]]=[m[y][x],m[x][y]];
    }
  }
  m.forEach(row=>row.reverse());
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    resetPlayer();
    arenaSweep();
  }
  dropCounter=0;
}

function playerMove(d){
  player.pos.x+=d;
  if(collide(arena,player)) player.pos.x-=d;
}

function playerRotate(){
  const pos=player.pos.x;
  let offset=1;
  rotate(player.matrix);
  while(collide(arena,player)){
    player.pos.x+=offset;
    offset=-(offset+(offset>0?1:-1));
    if(offset>player.matrix[0].length){
      rotate(player.matrix);
      player.pos.x=pos;
      return;
    }
  }
}

let dropCounter=0;
let dropInterval=600;
let lastTime=0;

function update(time=0){
  const delta=time-lastTime;
  lastTime=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval) playerDrop();
  draw();
  requestAnimationFrame(update);
}

const arena=createMatrix(12,20);
const player={pos:{x:0,y:0},matrix:null};

function resetPlayer(){
  const pieces="TJLOSZI";
  player.matrix=createPiece(pieces[Math.floor(Math.random()*pieces.length)]);
  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
  if(collide(arena,player)) arena.forEach(r=>r.fill(0));
}

document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft") playerMove(-1);
  else if(e.key==="ArrowRight") playerMove(1);
  else if(e.key==="ArrowDown") playerDrop();
  else if(e.key==="ArrowUp") playerRotate();
});

resetPlayer();
update();
</script>
</body>
</html>
